##并行数据处理与性能

并行流使用的线程池

    线程池大小默认为处理器数量，不建议修改
 
产生一个数字流

    使用
    Stream.iterate(start, i -> i + 1)   存在拆箱成本; 无限流，不易并行化
    LongStream.rangeClosed(n, m)    产生long，没有拆箱成本；有明确范围的流，易并行化

高效使用并行流的考虑因素

    拆、装箱成本
    操作本身是顺序的，例如limit、findFirst
    考虑流的操作流水线的总计算成本
    数据量的大小
    背后的数据结构是否易于分解 -> 关于这一点可以看下面的表格
    流本身的特点，以及中间操作修改流的方式，如果引入了不确定性比如筛选操作可能丢弃的元素个数无法预测，从而导致的流本身的大小未知
    合并步骤的代价大小

流的数据源与可分解性

    源               可分解性
    ArrayList        极佳
    LinkedList       差
    IntStream.range  极佳
    Stream.iterate   差
    HashSet          好
    TreeSet          好
   
分支/合并（fork/join） 框架
一些已知的事实

    调用join方法会阻塞调用方。因此，有必要在两个子任务的计算都开始之后再调用它。
    不应在RecurisveTask内部使用ForkJoinPool的invoke方法。
    对子任务调用fork方法可以把它排进ForkJoinPool。同时对左边和右边的自任务调用它似乎很自然，但这样做的效率要比直接对其中一个调用compute低。这样做你可以为其中一个子任务重用同一线程
    ，从而避免在线程池中多分配一个任务造成的开销。
    调试变得棘手了。调用compute的线程并不是概念上的调用方，后者（概念上的调用方）是调用fork的那个。
    与并行流一样，并不能认为分支/合并计算比顺序计算快。
